## Замыкание (closure)

Замыкание - это функция, которая запоминает своё лексическое окружение в момент создания. Лексическое окружение включает в себя все переменные, которые были видны функции в момент её создания.

#### Статьи
  1. [Область видимости переменных, замыкание](https://learn.javascript.ru/closure)
  2. [Замыкания в JavaScript для начинающих](https://habr.com/ru/companies/ruvds/articles/424967/)

#### Задачи 
---
1. Что код выведет в консоли
   
    ```javascript
    function makeWorker() {
      let name = "Pete";

      return function() {
        console.log(name);
      };
    }

    let name = "John";

    // создаём функцию
    let work = makeWorker();

    // вызываем её
    work(); // что будет показано?
   ```

   <details>
     <summary>Ответ</summary>

      >Pete
   </details>
2. Здесь мы делаем два счётчика: `counter` и `counter2`, используя одну и ту же функцию `makeCounter`. <br/>
   Они независимы? Что покажет второй счётчик? 0, 1 или 2, 3 или что-то ещё?
    ```javascript
    function makeCounter() {
      let count = 0;

      return function() {
        return count++;
      };
    }

    let counter = makeCounter();
    let counter2 = makeCounter();

    console.log( counter() ); // 0
    console.log( counter() ); // 1

    console.log( counter2() ); // ?
    console.log( counter2() ); // ?
    ```

    <details>
     <summary>Ответ</summary>

      >0,1. \
      Функции `counter` и `counter2` созданы разными вызовами `makeCounter`. \
      Так что у них независимые внешние лексические окружения, у каждого из которых свой собственный `count`.
   </details>

  3. Что выведет данный код?
     ```javascript
     let x = 1;

      function func() {
      console.log(x); // ?

      let x = 2;
      }

      func();
     ```

     <details>
     <summary>Ответ</summary>

      >Ошибка: ReferenceError: Cannot access 'x' before initialization
     </details>
  4. Следующий код создаёт массив из стрелков (`shooters`). <br/>
     Каждая функция предназначена выводить их порядковые номера. Но что-то пошло не так… <br/>
     Почему у всех стрелков одинаковые номера? <br/>
     Почините код, чтобы он работал как задумано.

     ```javascript
      function makeArmy() {
     let shooters = [];

     let i = 0;
     while (i < 10) {
      let shooter = function() { // функция shooter
      console.log( i ); // должна выводить порядковый номер
      };
      shooters.push(shooter); // и добавлять стрелка в массив
      i++;
     }

      // ...а в конце вернуть массив из всех стрелков
      return shooters;
      }

      let army = makeArmy();

      // все стрелки выводят 10 вместо их порядковых номеров (0, 1, 2, 3...)
      army[0](); // 10 от стрелка с порядковым номером 0
      army[1](); // 10 от стрелка с порядковым номером 1
      army[2](); // 10 ...и т.д.
     ```

     <details>
       <summary>Ответ</summary>

     Всё потому, что внутри функций `shooter` нет локальной переменной `i`. Когда вызывается такая функция, она берёт `i` из своего     
     внешнего лексического окружения. На момент вызова функции `shooter` из массива,  `makeArmy` уже завершила свою работу, и последнее          значение `i: 10` (конец цикла `while`). <br/>
     Как результат, все функции `shooter` получат одно и то же значение из внешнего лексического окружения: последнее значение `i=10`. <br/>
     Для исправления данного кода, мы можем воспользоваться знанием о том что на каждой итерации блока `while {...}` создается новое             лексическое окружени, поэтому мы можем скопировать значение `i` в переменную внутри блока `while {...}`, например, так:

         ```javascript
           function makeArmy() {
             let shooters = [];
    
             let i = 0;
             while (i < 10) {
                let j = i;
                let shooter = function() { // функция shooter
                  console.log( j ); // должна выводить порядковый номер
                };
               shooters.push(shooter);
               i++;
             }

             return shooters;
           }

         let army = makeArmy();

          // теперь код работает правильно
          army[0](); // 0
          army[5](); // 5
         ```
      Здесь `let j = i` объявляет «итерационно-локальную» переменную `j` и копирует в нее `i`. Примитивы копируются «по значению», поэтому        фактически мы получаем независимую копию `i`, принадлежащую текущей итерации цикла.
      Функции shooter работают правильно, потому что значение i теперь живет чуть ближе.

     </details>


